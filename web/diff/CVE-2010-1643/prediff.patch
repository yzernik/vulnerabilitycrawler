   nfsd: fix vm overcommit crash
   
   Junjiro R.  Okajima reported a problem where knfsd crashes if you are
   using it to export shmemfs objects and run strict overcommit.  In this
   situation the current->mm based modifier to the overcommit goes through a
   NULL pointer.
   
   We could simply check for NULL and skip the modifier but we've caught
   other real bugs in the past from mm being NULL here - cases where we did
   need a valid mm set up (eg the exec bug about a year ago).
   
   To preserve the checks and get the logic we want shuffle the checking
   around and add a new helper to the vm_ security wrappers
   
   Also fix a current->mm reference in nommu that should use the passed mm
   
   [akpm@linux-foundation.org: coding-style fixes]
   [akpm@linux-foundation.org: fix build]
   Reported-by: Junjiro R. Okajima <hooanon05@yahoo.co.jp>
   Acked-by: James Morris <jmorris@namei.org>
   Signed-off-by: Alan Cox <alan@redhat.com>
   Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
   Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
int security_settime(struct timespec *ts, struct timezone *tz);
int security_vm_enough_memory(long pages);
int security_vm_enough_memory_mm(struct mm_struct *mm, long pages);
int security_bprm_alloc(struct linux_binprm *bprm);
void security_bprm_free(struct linux_binprm *bprm);
void security_bprm_apply_creds(struct linux_binprm *bprm, int unsafe);
	return cap_vm_enough_memory(current->mm, pages);
}

static inline int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
{
	return cap_vm_enough_memory(mm, pages);

	/* Don't let a single process grow too big:
	   leave 3% of the size of this process for other processes */
	allowed -= mm->total_vm / 32;

	/*
	 * cast `allowed' as a signed long because vm_committed_space

	/* Don't let a single process grow too big:
	   leave 3% of the size of this process for other processes */
	allowed -= current->mm->total_vm / 32;

	/*
	 * cast `allowed' as a signed long because vm_committed_space
 */
static inline int shmem_acct_size(unsigned long flags, loff_t size)
{
	return (flags & VM_ACCOUNT)?
		security_vm_enough_memory(VM_ACCT(size)): 0;
}

static inline void shmem_unacct_size(unsigned long flags, loff_t size)
 */
static inline int shmem_acct_block(unsigned long flags)
{
	return (flags & VM_ACCOUNT)?
		0: security_vm_enough_memory(VM_ACCT(PAGE_CACHE_SIZE));
}

static inline void shmem_unacct_blocks(unsigned long flags, long pages)

int security_vm_enough_memory(long pages)
{
	return security_ops->vm_enough_memory(current->mm, pages);
}

int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
{
	return security_ops->vm_enough_memory(mm, pages);
}

int security_bprm_alloc(struct linux_binprm *bprm)
{
	return security_ops->bprm_alloc_security(bprm);
