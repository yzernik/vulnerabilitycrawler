   drm/r128: Add test for initialisation to all ioctls that require it
   
   Almost all r128's private ioctls require that the CCE state has
   already been initialised.  However, most do not test that this has
   been done, and will proceed to dereference a null pointer.  This may
   result in a security vulnerability, since some ioctls are
   unprivileged.
   
   This adds a macro for the common initialisation test and changes all
   ioctl implementations that require prior initialisation to use that
   macro.
   
   Also, r128_do_init_cce() does not test that the CCE state has not
   been initialised already.  Repeated initialisation may lead to a crash
   or resource leak.  This adds that test.
   
   Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
   Signed-off-by: Dave Airlie <airlied@redhat.com>

	DRM_DEBUG("\n");

	dev_priv = kzalloc(sizeof(drm_r128_private_t), GFP_KERNEL);
	if (dev_priv == NULL)
		return -ENOMEM;

	LOCK_TEST_WITH_RETURN(dev, file_priv);

	if (dev_priv->cce_running || dev_priv->cce_mode == R128_PM4_NONPM4) {
		DRM_DEBUG("while CCE running\n");
		return 0;

	LOCK_TEST_WITH_RETURN(dev, file_priv);

	/* Flush any pending CCE commands.  This ensures any outstanding
	 * commands are exectuted by the engine before we turn it off.
	 */

	LOCK_TEST_WITH_RETURN(dev, file_priv);

	if (!dev_priv) {
		DRM_DEBUG("called before init done\n");
		return -EINVAL;
	}

	r128_do_cce_reset(dev_priv);


	LOCK_TEST_WITH_RETURN(dev, file_priv);

	if (dev_priv->cce_running) {
		r128_do_cce_flush(dev_priv);
	}

	LOCK_TEST_WITH_RETURN(dev, file_priv);

	return r128_do_engine_reset(dev);
}

 * Misc helper macros
 */

#define RING_SPACE_TEST_WITH_RETURN( dev_priv )				\
do {									\
	drm_r128_ring_buffer_t *ring = &dev_priv->ring; int i;		\
static int r128_cce_clear(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
	drm_r128_private_t *dev_priv = dev->dev_private;
	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
	drm_r128_clear_t *clear = data;
	DRM_DEBUG("\n");

	LOCK_TEST_WITH_RETURN(dev, file_priv);

	RING_SPACE_TEST_WITH_RETURN(dev_priv);

	if (sarea_priv->nbox > R128_NR_SAREA_CLIPRECTS)
		sarea_priv->nbox = R128_NR_SAREA_CLIPRECTS;


	LOCK_TEST_WITH_RETURN(dev, file_priv);

	RING_SPACE_TEST_WITH_RETURN(dev_priv);

	if (!dev_priv->page_flipping)

	LOCK_TEST_WITH_RETURN(dev, file_priv);

	RING_SPACE_TEST_WITH_RETURN(dev_priv);

	if (sarea_priv->nbox > R128_NR_SAREA_CLIPRECTS)

	LOCK_TEST_WITH_RETURN(dev, file_priv);

	if (!dev_priv) {
		DRM_ERROR("called with no initialization\n");
		return -EINVAL;
	}

	DRM_DEBUG("pid=%d index=%d count=%d discard=%d\n",
		  DRM_CURRENTPID, vertex->idx, vertex->count, vertex->discard);

	LOCK_TEST_WITH_RETURN(dev, file_priv);

	if (!dev_priv) {
		DRM_ERROR("called with no initialization\n");
		return -EINVAL;
	}

	DRM_DEBUG("pid=%d buf=%d s=%d e=%d d=%d\n", DRM_CURRENTPID,
		  elts->idx, elts->start, elts->end, elts->discard);

	LOCK_TEST_WITH_RETURN(dev, file_priv);

	DRM_DEBUG("pid=%d index=%d\n", DRM_CURRENTPID, blit->idx);

	if (blit->idx < 0 || blit->idx >= dma->buf_count) {

	LOCK_TEST_WITH_RETURN(dev, file_priv);

	RING_SPACE_TEST_WITH_RETURN(dev_priv);

	ret = -EINVAL;

	LOCK_TEST_WITH_RETURN(dev, file_priv);

	if (DRM_COPY_FROM_USER(&mask, stipple->mask, 32 * sizeof(u32)))
		return -EFAULT;


	LOCK_TEST_WITH_RETURN(dev, file_priv);

	if (!dev_priv) {
		DRM_ERROR("called with no initialization\n");
		return -EINVAL;
	}

	DRM_DEBUG("idx=%d s=%d e=%d d=%d\n",
		  indirect->idx, indirect->start, indirect->end,
	drm_r128_getparam_t *param = data;
	int value;

	if (!dev_priv) {
		DRM_ERROR("called with no initialization\n");
		return -EINVAL;
	}

	DRM_DEBUG("pid=%d\n", DRM_CURRENTPID);

