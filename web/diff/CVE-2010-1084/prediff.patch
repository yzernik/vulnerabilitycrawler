   Bluetooth: Fix potential bad memory access with sysfs files
   
   When creating a high number of Bluetooth sockets (L2CAP, SCO
   and RFCOMM) it is possible to scribble repeatedly on arbitrary
   pages of memory. Ensure that the content of these sysfs files is
   always less than one page. Even if this means truncating. The
   files in question are scheduled to be moved over to debugfs in
   the future anyway.
   
   Based on initial patches from Neil Brown and Linus Torvalds
   
   Reported-by: Neil Brown <neilb@suse.de>
   Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
	struct sock *sk;
	struct hlist_node *node;
	char *str = buf;

	read_lock_bh(&l2cap_sk_list.lock);

	sk_for_each(sk, node, &l2cap_sk_list.head) {
		struct l2cap_pinfo *pi = l2cap_pi(sk);

		str += sprintf(str, "%s %s %d %d 0x%4.4x 0x%4.4x %d %d %d\n",
				batostr(&bt_sk(sk)->src), batostr(&bt_sk(sk)->dst),
				sk->sk_state, __le16_to_cpu(pi->psm), pi->scid,
				pi->dcid, pi->imtu, pi->omtu, pi->sec_level);
	}

	read_unlock_bh(&l2cap_sk_list.lock);
	struct rfcomm_session *s;
	struct list_head *pp, *p;
	char *str = buf;

	rfcomm_lock();

		list_for_each(pp, &s->dlcs) {
			struct sock *sk = s->sock->sk;
			struct rfcomm_dlc *d = list_entry(pp, struct rfcomm_dlc, list);

			str += sprintf(str, "%s %s %ld %d %d %d %d\n",
					batostr(&bt_sk(sk)->src), batostr(&bt_sk(sk)->dst),
					d->state, d->dlci, d->mtu, d->rx_credits, d->tx_credits);
		}
	}

	rfcomm_unlock();
	struct sock *sk;
	struct hlist_node *node;
	char *str = buf;

	read_lock_bh(&rfcomm_sk_list.lock);

	sk_for_each(sk, node, &rfcomm_sk_list.head) {
		str += sprintf(str, "%s %s %d %d\n",
				batostr(&bt_sk(sk)->src), batostr(&bt_sk(sk)->dst),
				sk->sk_state, rfcomm_pi(sk)->channel);
	}

	read_unlock_bh(&rfcomm_sk_list.lock);
	struct sock *sk;
	struct hlist_node *node;
	char *str = buf;

	read_lock_bh(&sco_sk_list.lock);

	sk_for_each(sk, node, &sco_sk_list.head) {
		str += sprintf(str, "%s %s %d\n",
				batostr(&bt_sk(sk)->src), batostr(&bt_sk(sk)->dst),
				sk->sk_state);
	}

	read_unlock_bh(&sco_sk_list.lock);
