   i386: fixup TRACE_IRQ breakage
   
   The TRACE_IRQS_ON function in iret_exc: calls a C function without
   ensuring that the segments are set properly. Move the trace function and
   the enabling of interrupt into the C stub.
   
   Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
   Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
1:	INTERRUPT_RETURN
.section .fixup,"ax"
iret_exc:
	TRACE_IRQS_ON
	ENABLE_INTERRUPTS(CLBR_NONE)
	pushl $0			# no error code
	pushl $do_iret_error
	jmp error_code
	do_trap(trapnr, signr, str, 0, regs, error_code, NULL); \
}

#define DO_ERROR_INFO(trapnr, signr, str, name, sicode, siaddr) \
fastcall void do_##name(struct pt_regs * regs, long error_code) \
{ \
	siginfo_t info; \
	info.si_signo = signr; \
	info.si_errno = 0; \
	info.si_code = sicode; \
#endif
DO_VM86_ERROR( 4, SIGSEGV, "overflow", overflow)
DO_VM86_ERROR( 5, SIGSEGV, "bounds", bounds)
DO_ERROR_INFO( 6, SIGILL,  "invalid opcode", invalid_op, ILL_ILLOPN, regs->eip)
DO_ERROR( 9, SIGFPE,  "coprocessor segment overrun", coprocessor_segment_overrun)
DO_ERROR(10, SIGSEGV, "invalid TSS", invalid_TSS)
DO_ERROR(11, SIGBUS,  "segment not present", segment_not_present)
DO_ERROR(12, SIGBUS,  "stack segment", stack_segment)
DO_ERROR_INFO(17, SIGBUS, "alignment check", alignment_check, BUS_ADRALN, 0)
DO_ERROR_INFO(32, SIGSEGV, "iret exception", iret_error, ILL_BADSTK, 0)

fastcall void __kprobes do_general_protection(struct pt_regs * regs,
					      long error_code)
