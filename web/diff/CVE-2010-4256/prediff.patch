   Export 'get_pipe_info()' to other users
   
   And in particular, use it in 'pipe_fcntl()'.
   
   The other pipe functions do not need to use the 'careful' version, since
   they are only ever called for things that are already known to be pipes.
   
   The normal read/write/ioctl functions are called through the file
   operations structures, so if a file isn't a pipe, they'd never get
   called.  But pipe_fcntl() is special, and called directly from the
   generic fcntl code, and needs to use the same careful function that the
   splice code is using.
   
   Cc: Jens Axboe <jaxboe@fusionio.com>
   Cc: Andrew Morton <akpm@linux-foundation.org>
   Cc: Al Viro <viro@zeniv.linux.org.uk>
   Cc: Dave Jones <davej@redhat.com>
   Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
	struct pipe_inode_info *pipe;
	long ret;

	pipe = file->f_path.dentry->d_inode->i_pipe;
	if (!pipe)
		return -EBADF;

static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,
			       struct pipe_inode_info *opipe,
			       size_t len, unsigned int flags);
/*
 * After the inode slimming patch, i_pipe/i_bdev/i_cdev share the same
 * location, so checking ->i_pipe is not enough to verify that this is a
 * pipe.
 */
static inline struct pipe_inode_info *get_pipe_info(struct file *file)
{
	struct inode *i = file->f_path.dentry->d_inode;

	return S_ISFIFO(i->i_mode) ? i->i_pipe : NULL;
}

/*
 * Determine where to splice to/from.
/* for F_SETPIPE_SZ and F_GETPIPE_SZ */
long pipe_fcntl(struct file *, unsigned int, unsigned long arg);

#endif
