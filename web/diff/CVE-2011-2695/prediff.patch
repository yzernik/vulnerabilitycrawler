   ext4: Fix max file size and logical block counting of extent format file
   
   Kazuya Mio reported that he was able to hit BUG_ON(next == lblock)
   in ext4_ext_put_gap_in_cache() while creating a sparse file in extent
   format and fill the tail of file up to its end. We will hit the BUG_ON
   when we write the last block (2^32-1) into the sparse file.
   
   The root cause of the problem lies in the fact that we specifically set
   s_maxbytes so that block at s_maxbytes fit into on-disk extent format,
   which is 32 bit long. However, we are not storing start and end block
   number, but rather start block number and length in blocks. It means
   that in order to cover extent from 0 to EXT_MAX_BLOCK we need
   EXT_MAX_BLOCK+1 to fit into len (because we counting block 0 as well) -
   and it does not.
   
   The only way to fix it without changing the meaning of the struct
   ext4_extent members is, as Kazuya Mio suggested, to lower s_maxbytes
   by one fs block so we can cover the whole extent we can get by the
   on-disk extent format.
   
   Also in many places EXT_MAX_BLOCK is used as length instead of maximum
   logical block number as the name suggests, it is all a bit messy. So
   this commit renames it to EXT_MAX_BLOCKS and change its usage in some
   places to actually be maximum number of blocks in the extent.
   
   The bug which this commit fixes can be reproduced as follows:
   
    dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-2))
    sync
    dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-1))
   
   Reported-by: Kazuya Mio <k-mio@sx.jp.nec.com>
   Signed-off-by: Lukas Czerner <lczerner@redhat.com>
   Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
#define EXT_BREAK      1
#define EXT_REPEAT     2

/* Maximum logical block in a file; ext4_extent's ee_block is __le32 */
#define EXT_MAX_BLOCK	0xffffffff

/*
 * EXT_INIT_MAX_LEN is the maximum number of blocks we can have in an

/*
 * ext4_ext_next_allocated_block:
 * returns allocated block in subsequent extent or EXT_MAX_BLOCK.
 * NOTE: it considers block number from index entry as
 * allocated block. Thus, index entries have to be consistent
 * with leaves.
	depth = path->p_depth;

	if (depth == 0 && path->p_ext == NULL)
		return EXT_MAX_BLOCK;

	while (depth >= 0) {
		if (depth == path->p_depth) {
		depth--;
	}

	return EXT_MAX_BLOCK;
}

/*
 * ext4_ext_next_leaf_block:
 * returns first allocated block from next leaf or EXT_MAX_BLOCK
 */
static ext4_lblk_t ext4_ext_next_leaf_block(struct inode *inode,
					struct ext4_ext_path *path)

	/* zero-tree has no leaf blocks at all */
	if (depth == 0)
		return EXT_MAX_BLOCK;

	/* go to index block */
	depth--;
		depth--;
	}

	return EXT_MAX_BLOCK;
}

/*
	 */
	if (b2 < b1) {
		b2 = ext4_ext_next_allocated_block(path);
		if (b2 == EXT_MAX_BLOCK)
			goto out;
	}

	/* check for wrap through zero on extent logical start block*/
	if (b1 + len1 < b1) {
		len1 = EXT_MAX_BLOCK - b1;
		newext->ee_len = cpu_to_le16(len1);
		ret = 1;
	}
	fex = EXT_LAST_EXTENT(eh);
	next = ext4_ext_next_leaf_block(inode, path);
	if (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block)
	    && next != EXT_MAX_BLOCK) {
		ext_debug("next leaf block - %d\n", next);
		BUG_ON(npath != NULL);
		npath = ext4_ext_find_extent(inode, next, NULL);
	BUG_ON(func == NULL);
	BUG_ON(inode == NULL);

	while (block < last && block != EXT_MAX_BLOCK) {
		num = last - block;
		/* find extent for this block */
		down_read(&EXT4_I(inode)->i_data_sem);
	if (ex == NULL) {
		/* there is no extent yet, so gap is [0;-] */
		lblock = 0;
		len = EXT_MAX_BLOCK;
		ext_debug("cache gap(whole file):");
	} else if (block < le32_to_cpu(ex->ee_block)) {
		lblock = block;
			 * never happen because at least one of the end points
			 * needs to be on the edge of the extent.
			 */
			if (end == EXT_MAX_BLOCK) {
				ext_debug("  bad truncate %u:%u\n",
						start, end);
				block = 0;
			 * If this is a truncate, this condition
			 * should never happen
			 */
			if (end == EXT_MAX_BLOCK) {
				ext_debug("  bad truncate %u:%u\n",
					start, end);
				err = -EIO;
		 * we need to remove it from the leaf
		 */
		if (num == 0) {
			if (end != EXT_MAX_BLOCK) {
				/*
				 * For hole punching, we need to scoot all the
				 * extents up when an extent is removed so that

	last_block = (inode->i_size + sb->s_blocksize - 1)
			>> EXT4_BLOCK_SIZE_BITS(sb);
	err = ext4_ext_remove_space(inode, last_block, EXT_MAX_BLOCK);

	/* In a multi-transaction truncate, we only make the final
	 * transaction synchronous.

		start_blk = start >> inode->i_sb->s_blocksize_bits;
		last_blk = (start + len - 1) >> inode->i_sb->s_blocksize_bits;
		if (last_blk >= EXT_MAX_BLOCK)
			last_blk = EXT_MAX_BLOCK-1;
		len_blks = ((ext4_lblk_t) last_blk) - start_blk + 1;

		/*
		return -EINVAL;
	}

	if ((orig_start > EXT_MAX_BLOCK) ||
	    (donor_start > EXT_MAX_BLOCK) ||
	    (*len > EXT_MAX_BLOCK) ||
	    (orig_start + *len > EXT_MAX_BLOCK))  {
		ext4_debug("ext4 move extent: Can't handle over [%u] blocks "
			"[ino:orig %lu, donor %lu]\n", EXT_MAX_BLOCK,
			orig_inode->i_ino, donor_inode->i_ino);
		return -EINVAL;
	}
 * in the vfs.  ext4 inode has 48 bits of i_block in fsblock units,
 * so that won't be a limiting factor.
 *
 * Note, this does *not* consider any metadata overhead for vfs i_blocks.
 */
static loff_t ext4_max_size(int blkbits, int has_huge_files)
		upper_limit <<= blkbits;
	}

	/* 32-bit extent-start container, ee_block */
	res = 1LL << 32;
	res <<= blkbits;
	res -= 1;

	/* Sanity check against vm- & vfs- imposed limits */
	if (res > upper_limit)
