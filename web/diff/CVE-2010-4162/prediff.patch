   bio: take care not overflow page count when mapping/copying user data
   
   If the iovec is being set up in a way that causes uaddr + PAGE_SIZE
   to overflow, we could end up attempting to map a huge number of
   pages. Check for this invalid input type.
   
   Reported-by: Dan Rosenberg <drosenberg@vsecurity.com>
   Cc: stable@kernel.org
   Signed-off-by: Jens Axboe <jaxboe@fusionio.com>
		end = (uaddr + iov[i].iov_len + PAGE_SIZE - 1) >> PAGE_SHIFT;
		start = uaddr >> PAGE_SHIFT;

		nr_pages += end - start;
		len += iov[i].iov_len;
	}
		unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
		unsigned long start = uaddr >> PAGE_SHIFT;

		nr_pages += end - start;
		/*
		 * buffer must be aligned to at least hardsector size for now
		unsigned long start = uaddr >> PAGE_SHIFT;
		const int local_nr_pages = end - start;
		const int page_limit = cur_page + local_nr_pages;
		
		ret = get_user_pages_fast(uaddr, local_nr_pages,
				write_to_vm, &pages[cur_page]);
		if (ret < local_nr_pages) {
