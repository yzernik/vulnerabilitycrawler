   can: add limit for nframes and clean up signed/unsigned variables
   
   This patch adds a limit for nframes as the number of frames in TX_SETUP and
   RX_SETUP are derived from a single byte multiplex value by default.
   Use-cases that would require to send/filter more than 256 CAN frames should
   be implemented in userspace for complexity reasons anyway.
   
   Additionally the assignments of unsigned values from userspace to signed
   values in kernelspace and vice versa are fixed by using unsigned values in
   kernelspace consistently.
   
   Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
   Reported-by: Ben Hawkes <hawkes@google.com>
   Acked-by: Urs Thuermann <urs.thuermann@volkswagen.de>
   Signed-off-by: David S. Miller <davem@davemloft.net>
#include <net/sock.h>
#include <net/net_namespace.h>

/* use of last_frames[index].can_dlc */
#define RX_RECV    0x40 /* received data for this element */
#define RX_THR     0x80 /* element not been sent due to throttle feature */
	struct list_head list;
	int ifindex;
	canid_t can_id;
	int flags;
	unsigned long frames_abs, frames_filtered;
	struct timeval ival1, ival2;
	struct hrtimer timer, thrtimer;
	struct tasklet_struct tsklet, thrtsklet;
	ktime_t rx_stamp, kt_ival1, kt_ival2, kt_lastmsg;
	int rx_ifindex;
	int count;
	int nframes;
	int currframe;
	struct can_frame *frames;
	struct can_frame *last_frames;
	struct can_frame sframe;

		seq_printf(m, "rx_op: %03X %-5s ",
				op->can_id, bcm_proc_getifname(ifname, op->ifindex));
		seq_printf(m, "[%d]%c ", op->nframes,
				(op->flags & RX_CHECK_DLC)?'d':' ');
		if (op->kt_ival1.tv64)
			seq_printf(m, "timeo=%lld ",

	list_for_each_entry(op, &bo->tx_ops, list) {

		seq_printf(m, "tx_op: %03X %s [%d] ",
				op->can_id,
				bcm_proc_getifname(ifname, op->ifindex),
				op->nframes);
	struct can_frame *firstframe;
	struct sockaddr_can *addr;
	struct sock *sk = op->sk;
	int datalen = head->nframes * CFSIZ;
	int err;

	skb = alloc_skb(sizeof(*head) + datalen, gfp_any());
 * bcm_rx_cmp_to_index - (bit)compares the currently received data to formerly
 *                       received data stored in op->last_frames[]
 */
static void bcm_rx_cmp_to_index(struct bcm_op *op, int index,
				const struct can_frame *rxdata)
{
	/*
/*
 * bcm_rx_do_flush - helper for bcm_rx_thr_flush
 */
static inline int bcm_rx_do_flush(struct bcm_op *op, int update, int index)
{
	if ((op->last_frames) && (op->last_frames[index].can_dlc & RX_THR)) {
		if (update)
	int updated = 0;

	if (op->nframes > 1) {
		int i;

		/* for MUX filter we start at index 1 */
		for (i = 1; i < op->nframes; i++)
{
	struct bcm_op *op = (struct bcm_op *)data;
	const struct can_frame *rxframe = (struct can_frame *)skb->data;
	int i;

	/* disable timeout */
	hrtimer_cancel(&op->timer);
{
	struct bcm_sock *bo = bcm_sk(sk);
	struct bcm_op *op;
	int i, err;

	/* we need a real device to send frames */
	if (!ifindex)
		return -ENODEV;

	/* we need at least one can_frame */
	if (msg_head->nframes < 1)
		return -EINVAL;

	/* check the given can_id */
		msg_head->nframes = 0;
	}

	if ((msg_head->flags & RX_RTR_FRAME) &&
	    ((msg_head->nframes != 1) ||
	     (!(msg_head->can_id & CAN_RTR_FLAG))))
