   splice: fix deadlock in splicing to file
   
   There's a possible deadlock in generic_file_splice_write(),
   splice_from_pipe() and ocfs2_file_splice_write():
   
    - task A calls generic_file_splice_write()
    - this calls inode_double_lock(), which locks i_mutex on both
      pipe->inode and target inode
    - ordering depends on inode pointers, can happen that pipe->inode is
      locked first
    - __splice_from_pipe() needs more data, calls pipe_wait()
    - this releases lock on pipe->inode, goes to interruptible sleep
    - task B calls generic_file_splice_write(), similarly to the first
    - this locks pipe->inode, then tries to lock inode, but that is
      already held by task A
    - task A is interrupted, it tries to lock pipe->inode, but fails, as
      it is already held by task B
    - ABBA deadlock
   
   Fix this by explicitly ordering locks: the outer lock must be on
   target inode and the inner lock (which is later unlocked and relocked)
   must be on pipe->inode.  This is OK, pipe inodes and target inodes
   form two nonoverlapping sets, generic_file_splice_write() and friends
   are not called with a target which is a pipe.
   
   Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
   Acked-by: Mark Fasheh <mfasheh@suse.com>
   Acked-by: Jens Axboe <jens.axboe@oracle.com>
   Cc: stable@kernel.org
   Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
		   out->f_path.dentry->d_name.len,
		   out->f_path.dentry->d_name.name);

	inode_double_lock(inode, pipe->inode);

	ret = ocfs2_rw_lock(inode, 1);
	if (ret < 0) {
		goto out_unlock;
	}

	ret = generic_file_splice_write_nolock(pipe, out, ppos, len, flags);

out_unlock:
	ocfs2_rw_unlock(inode, 1);
out:
	inode_double_unlock(inode, pipe->inode);

	mlog_exit(ret);
	return ret;
	 * ->write_end. Most of the time, these expect i_mutex to
	 * be held. Since this may result in an ABBA deadlock with
	 * pipe->inode, we have to order lock acquiry here.
	 */
	inode_double_lock(inode, pipe->inode);
	ret = __splice_from_pipe(pipe, &sd, actor);
	inode_double_unlock(inode, pipe->inode);

	return ret;
}
	};
	ssize_t ret;

	inode_double_lock(inode, pipe->inode);
	ret = file_remove_suid(out);
	if (likely(!ret))
		ret = __splice_from_pipe(pipe, &sd, pipe_to_file);
	inode_double_unlock(inode, pipe->inode);
	if (ret > 0) {
		unsigned long nr_pages;

