commit babd03fde68093482528010a5435c14ce9128e3f
Author: Jim Paris <jim@jtan.com>
Date:   Mon Aug 24 14:56:12 2009 -0400

    usb-linux.c: fix buffer overflow
    
    In usb-linux.c:usb_host_handle_control, we pass a 1024-byte buffer and
    length to the kernel.  However, the length was provided by the caller
    of dev->handle_packet, and is not checked, so the kernel might provide
    too much data and overflow our buffer.
    
    For example, hw/usb-uhci.c could set the length to 2047.
    hw/usb-ohci.c looks like it might go up to 4096 or 8192.
    
    This causes a qemu crash, as reported here:
      http://www.mail-archive.com/kvm@vger.kernel.org/msg18447.html
    
    This patch increases the usb-linux.c buffer size to 2048 to fix the
    specific device reported, and adds a check to avoid the overflow in
    any case.
    
    Signed-off-by: Jim Paris <jim@jtan.com>
    Signed-off-by: Anthony Liguori <aliguori@us.ibm.com>

diff --git a/usb-linux.c b/usb-linux.c
index 043f6b6..eb1c5f0 100644
--- a/usb-linux.c
+++ b/usb-linux.c
@@ -113,9 +113,9 @@ enum {
 struct ctrl_struct {
     uint16_t len;
     uint16_t offset;
     uint8_t  state;
     struct   usb_ctrlrequest req;
-    uint8_t  buffer[1024];
+    uint8_t  buffer[2048];
 };
 
 typedef struct USBHostDevice {
@@ -550,74 +550,82 @@ static int usb_host_set_interface(USBHostDevice *s, int iface, int alt)
 static int usb_host_handle_control(USBHostDevice *s, USBPacket *p)
 {
     struct usbdevfs_urb *urb;
     AsyncURB *aurb;
     int ret, value, index;
+    int buffer_len;
 
     /* 
      * Process certain standard device requests.
      * These are infrequent and are processed synchronously.
      */
     value = le16_to_cpu(s->ctrl.req.wValue);
     index = le16_to_cpu(s->ctrl.req.wIndex);
 
     dprintf("husb: ctrl type 0x%x req 0x%x val 0x%x index %u len %u\n",
         s->ctrl.req.bRequestType, s->ctrl.req.bRequest, value, index, 
         s->ctrl.len);
 
     if (s->ctrl.req.bRequestType == 0) {
         switch (s->ctrl.req.bRequest) {
         case USB_REQ_SET_ADDRESS:
             return usb_host_set_address(s, value);
 
         case USB_REQ_SET_CONFIGURATION:
             return usb_host_set_config(s, value & 0xff);
         }
     }
 
     if (s->ctrl.req.bRequestType == 1 &&
                   s->ctrl.req.bRequest == USB_REQ_SET_INTERFACE)
         return usb_host_set_interface(s, index, value);
 
     /* The rest are asynchronous */
 
+    buffer_len = 8 + s->ctrl.len;
+    if (buffer_len > sizeof(s->ctrl.buffer)) {
+	    fprintf(stderr, "husb: ctrl buffer too small (%u > %lu)\n",
+		    buffer_len, sizeof(s->ctrl.buffer));
+	    return USB_RET_STALL;
+    }
+
     aurb = async_alloc();
     aurb->hdev   = s;
     aurb->packet = p;
 
     /* 
      * Setup ctrl transfer.
      *
      * s->ctrl is layed out such that data buffer immediately follows
      * 'req' struct which is exactly what usbdevfs expects.
      */ 
     urb = &aurb->urb;
 
     urb->type     = USBDEVFS_URB_TYPE_CONTROL;
     urb->endpoint = p->devep;
 
     urb->buffer        = &s->ctrl.req;
-    urb->buffer_length = 8 + s->ctrl.len;
+    urb->buffer_length = buffer_len;
 
     urb->usercontext = s;
 
     ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);
 
     dprintf("husb: submit ctrl. len %u aurb %p\n", urb->buffer_length, aurb);
 
     if (ret < 0) {
         dprintf("husb: submit failed. errno %d\n", errno);
         async_free(aurb);
 
         switch(errno) {
         case ETIMEDOUT:
             return USB_RET_NAK;
         case EPIPE:
         default:
             return USB_RET_STALL;
         }
     }
 
     usb_defer_packet(p, async_cancel, aurb);
     return USB_RET_ASYNC;
 }
 
