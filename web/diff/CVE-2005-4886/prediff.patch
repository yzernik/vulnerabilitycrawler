   [SELINUX]: Fix ipv6_skip_exthdr() invocation causing OOPS.
   
   The SELinux hooks invoke ipv6_skip_exthdr() with an incorrect
   length final argument.  However, the length argument turns out
   to be superfluous.
   
   I was just reading ipv6_skip_exthdr and it occured to me that we can
   get rid of len altogether.  The only place where len is used is to
   check whether the skb has two bytes for ipv6_opt_hdr.  This check
   is done by skb_header_pointer/skb_copy_bits anyway.
   
   Now it might appear that we've made the code slower by deferring
   the check to skb_copy_bits.  However, this check should not trigger
   in the common case so this is OK.
   
   Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
   Signed-off-by: David S. Miller <davem@davemloft.net>
						    u8 *proto);

extern int			ipv6_skip_exthdr(const struct sk_buff *, int start,
					         u8 *nexthdrp, int len);

extern int 			ipv6_ext_hdr(u8 nexthdr);

 * when Linux implements ESP (and maybe AUTH) headers.
 * --AK
 *
 * This function parses (probably truncated) exthdr set "hdr"
 * of length "len". "nexthdrp" initially points to some place,
 * where type of the first header can be found.
 *
 * It skips all well-known exthdrs, and returns pointer to the start
 * --ANK (980726)
 */

int ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp, int len)
{
	u8 nexthdr = *nexthdrp;

		struct ipv6_opt_hdr _hdr, *hp;
		int hdrlen;

		if (len < (int)sizeof(struct ipv6_opt_hdr))
			return -1;
		if (nexthdr == NEXTHDR_NONE)
			return -1;
		hp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);
		if (hp == NULL)
			BUG();
		if (nexthdr == NEXTHDR_FRAGMENT) {
			unsigned short _frag_off, *fp;
			fp = skb_header_pointer(skb,
			hdrlen = ipv6_optlen(hp); 

		nexthdr = hp->nexthdr;
		len -= hdrlen;
		start += hdrlen;
	}

	if (len < 0)
		return 1;

	ptr = ipv6_skip_exthdr(skb, ptr, &nexthdr, len);
	if (ptr < 0)
		return 0;
	if (nexthdr == IPPROTO_ICMPV6) {
	nexthdr = ((struct ipv6hdr *)skb->data)->nexthdr;
	if (ipv6_ext_hdr(nexthdr)) {
		/* now skip over extension headers */
		inner_offset = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr, skb->len - sizeof(struct ipv6hdr));
		if (inner_offset<0)
			return;
	} else {

	nexthdr = ip6->nexthdr;
	offset += sizeof(_ipv6h);
	offset = ipv6_skip_exthdr(skb, offset, &nexthdr,
				  skb->tail - skb->head - offset);
	if (offset < 0)
		goto out;

