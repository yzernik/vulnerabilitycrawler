   oom: fix the unsafe usage of badness() in proc_oom_score()
   
   proc_oom_score(task) has a reference to task_struct, but that is all.
   If this task was already released before we take tasklist_lock
   
   	- we can't use task->group_leader, it points to nowhere
   
   	- it is not safe to call badness() even if this task is
   	  ->group_leader, has_intersects_mems_allowed() assumes
   	  it is safe to iterate over ->thread_group list.
   
   	- even worse, badness() can hit ->signal == NULL
   
   Add the pid_alive() check to ensure __unhash_process() was not called.
   
   Also, use "task" instead of task->group_leader. badness() should return
   the same result for any sub-thread. Currently this is not true, but
   this should be changed anyway.
   
   Signed-off-by: Oleg Nesterov <oleg@redhat.com>
   Cc: stable@kernel.org
   Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
unsigned long badness(struct task_struct *p, unsigned long uptime);
static int proc_oom_score(struct task_struct *task, char *buffer)
{
	unsigned long points;
	struct timespec uptime;

	do_posix_clock_monotonic_gettime(&uptime);
	read_lock(&tasklist_lock);
	points = badness(task->group_leader, uptime.tv_sec);
	read_unlock(&tasklist_lock);
	return sprintf(buffer, "%lu\n", points);
}
